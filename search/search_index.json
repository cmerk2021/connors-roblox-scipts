{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Connor's Roblox Scripts","text":"<p>On this website, I will share all my useful roblox scripts, modules, and more that can be implimented into any Roblox game!</p> <p>My goal is to provide safe, easy to use items for any Roblox game. To learn more, you can email me or join my Discord Server!</p>"},{"location":"advanced-math/","title":"Advanced Math Module","text":""},{"location":"advanced-math/#roblox-math-module-documentation","title":"Roblox Math Module Documentation","text":"<p>This document explains the functionality of the <code>math_module</code> Lua module for Roblox. This module provides various mathematical functions categorized into basic, advanced, trigonometric, hyperbolic, vector, matrix, and statistical functions.</p>"},{"location":"advanced-math/#usage","title":"Usage","text":"<p>To use this module in your Roblox script, place the following script in a <code>ModuleScript</code> in <code>ReplicatedStorage</code>.</p> <pre><code>-- math_module.lua\n\nlocal math_module = {}\n\n-- Simple Math Functions\n\nfunction math_module.add(a, b)\n    return a + b\nend\n\nfunction math_module.sub(a, b)\n    return a - b\nend\n\nfunction math_module.mul(a, b)\n    return a * b\nend\n\nfunction math_module.div(a, b)\n    if b == 0 then\n        error(\"Cannot divide by zero!\")\n    end\n    return a / b\nend\n\nfunction math_module.mod(a, b)\n    return a % b\nend\n\nfunction math_module.pow(a, b)\n    return a ^ b\nend\n\n-- Advanced Math Functions\n\nfunction math_module.sqrt(a)\n    return math.sqrt(a)\nend\n\nfunction math_module.abs(a)\n    return math.abs(a)\nend\n\nfunction math_module.sin(a)\n    return math.sin(a)\nend\n\nfunction math_module.cos(a)\n    return math.cos(a)\nend\n\nfunction math_module.tan(a)\n    return math.tan(a)\nend\n\nfunction math_module.asin(a)\n    return math.asin(a)\nend\n\nfunction math_module.acos(a)\n    return math.acos(a)\nend\n\nfunction math_module.atan(a)\n    return math.atan(a)\nend\n\nfunction math_module.atan2(y, x)\n    return math.atan2(y, x)\nend\n\nfunction math_module.log(a, base)\n    if base then\n        return math.log(a) / math.log(base)\n    else\n        return math.log(a)\n    end\nend\n\nfunction math_module.exp(a)\n    return math.exp(a)\nend\n\nfunction math_module.ceil(a)\n    return math.ceil(a)\nend\n\nfunction math_module.floor(a)\n    return math.floor(a)\nend\n\nfunction math_module.round(a)\n    return math.floor(a + 0.5)\nend\n\n-- Trigonometric Functions\n\nfunction math_module.cot(a)\n    return 1 / math.tan(a)\nend\n\nfunction math_module.sec(a)\n    return 1 / math.cos(a)\nend\n\nfunction math_module.csc(a)\n    return 1 / math.sin(a)\nend\n\nfunction math_module.hypot(a, b)\n    return math.sqrt(a ^ 2 + b ^ 2)\nend\n\n-- Hyperbolic Functions\n\nfunction math_module.sinh(a)\n    return (math.exp(a) - math.exp(-a)) / 2\nend\n\nfunction math_module.cosh(a)\n    return (math.exp(a) + math.exp(-a)) / 2\nend\n\nfunction math_module.tanh(a)\n    return math.sinh(a) / math.cosh(a)\nend\n\nfunction math_module.asinh(a)\n    return math.log(a + math.sqrt(a ^ 2 + 1))\nend\n\nfunction math_module.acosh(a)\n    return math.log(a + math.sqrt(a ^ 2 - 1))\nend\n\nfunction math_module.atanh(a)\n    return math.log((1 + a) / (1 - a)) / 2\nend\n\n-- Vector Math Functions\n\nfunction math_module.dot(a, b)\n    return a.x * b.x + a.y * b.y + a.z * b.z\nend\n\nfunction math_module.cross(a, b)\n    return Vector3.new(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)\nend\n\nfunction math_module.magnitude(a)\n    return math.sqrt(a.x ^ 2 + a.y ^ 2 + a.z ^ 2)\nend\n\nfunction math_module.normalize(a)\n    local magnitude = math_module.magnitude(a)\n    return Vector3.new(a.x / magnitude, a.y / magnitude, a.z / magnitude)\nend\n\nfunction math_module.distance(a, b)\n    return math.sqrt((a.x - b.x) ^ 2 + (a.y - b.y) ^ 2 + (a.z - b.z) ^ 2)\nend\n\nfunction math_module.angleBetween(a, b)\n    local dotProduct = math_module.dot(a, b)\n    local magnitudeA = math_module.magnitude(a)\n    local magnitudeB = math_module.magnitude(b)\n    return math.acos(dotProduct / (magnitudeA * magnitudeB))\nend\n\n-- Matrix Math Functions\n\nfunction math_module.multiplyMatrix(a, b)\n    local result = {}\n    for i = 1, 4 do\n        result[i] = {}\n        for j = 1, 4 do\n            result[i][j] = 0\n            for k = 1, 4 do\n                result[i][j] = result[i][j] + a[i][k] * b[k][j]\n            end\n        end\n    end\n    return result\nend\n\nfunction math_module.invertMatrix(a)\n    -- implement matrix inversion algorithm here\n    -- for now, just return the identity matrix\nreturn {\n        {1, 0, 0, 0},\n        {0, 1, 0, 0},\n        {0, 0, 1, 0},\n        {0, 0, 0, 1}\n    }\nend\n\n-- Statistical Functions\n\nfunction math_module.mean(numbers)\n    local sum = 0\n    for i, number in ipairs(numbers) do\n        sum = sum + number\n    end\n    return sum / #numbers\nend\n\nfunction math_module.median(numbers)\n    table.sort(numbers)\n    local midIndex = math.floor(#numbers / 2)\n    if #numbers % 2 == 0 then\n        return (numbers[midIndex] + numbers[midIndex + 1]) / 2\n    else\n        return numbers[midIndex]\n    end\nend\n\nfunction math_module.mode(numbers)\n    local frequencyTable = {}\n    for i, number in ipairs(numbers) do\n        if not frequencyTable[number] then\n            frequencyTable[number] = 1\n        else\n            frequencyTable[number] = frequencyTable[number] + 1\n        end\n    end\n    local maxFrequency = 0\n    local mode = nil\n    for number, frequency in pairs(frequencyTable) do\n        if frequency &gt; maxFrequency then\n            maxFrequency = frequency\n            mode = number\n        end\n    end\n    return mode\nend\n\nfunction math_module.standardDeviation(numbers)\n    local mean = math_module.mean(numbers)\n    local variance = 0\n    for i, number in ipairs(numbers) do\n        variance = variance + (number - mean) ^ 2\n    end\n    variance = variance / #numbers\n    return math.sqrt(variance)\nend\n\nreturn math_module\n</code></pre> <p>Now, require it in any script.</p> <pre><code>local math_module = require(game.ReplicatedStorage.PathToModule)\n</code></pre> <p>Replace <code>PathToModule</code> with the actual path to the script containing the <code>math_module</code> code. Then, you can call the desired functions from the module, like this:</p> <pre><code>local result = math_module.add(5, 3) -- result will be 8\n</code></pre>"},{"location":"advanced-math/#simple-math-functions","title":"Simple Math Functions","text":"<ul> <li>add(a, b): Adds two numbers <code>a</code> and <code>b</code> and returns the sum.</li> <li>sub(a, b): Subtracts <code>b</code> from <code>a</code> and returns the difference.</li> <li>mul(a, b): Multiplies <code>a</code> by <code>b</code> and returns the product.</li> <li>div(a, b): Divides <code>a</code> by <code>b</code> and returns the quotient. Note: This function throws an error if <code>b</code> is zero.</li> <li>mod(a, b): Returns the remainder of dividing <code>a</code> by <code>b</code>.</li> <li>pow(a, b): Raises <code>a</code> to the power of <code>b</code> and returns the result.</li> </ul>"},{"location":"advanced-math/#advanced-math-functions","title":"Advanced Math Functions","text":"<p>These functions utilize Lua's built-in math library for advanced operations.</p> <ul> <li>sqrt(a): Calculates the square root of <code>a</code>.</li> <li>abs(a): Returns the absolute value of <code>a</code>.</li> <li>sin(a): Calculates the sine of <code>a</code> in radians.</li> <li>cos(a): Calculates the cosine of <code>a</code> in radians.</li> <li>tan(a): Calculates the tangent of <code>a</code> in radians.</li> <li>asin(a): Calculates the arcsine of <code>a</code> in radians (inverse sine).</li> <li>acos(a): Calculates the arccosine of <code>a</code> in radians (inverse cosine).</li> <li>atan(a): Calculates the arctangent of <code>a</code> in radians (inverse tangent).</li> <li>atan2(y, x): Calculates the arctangent of <code>y / x</code> in radians, considering the signs to determine the quadrant.</li> <li>log(a, base): Calculates the logarithm of <code>a</code> with optional base. If no base is provided, it defaults to base 10 (common logarithm).</li> <li>exp(a): Calculates the value of e raised to the power of <code>a</code>.</li> <li>ceil(a): Returns the smallest integer greater than or equal to <code>a</code>.</li> <li>floor(a): Returns the largest integer less than or equal to <code>a</code>.</li> <li>round(a): Rounds <code>a</code> to the nearest integer.</li> </ul>"},{"location":"advanced-math/#trigonometric-functions-derived","title":"Trigonometric Functions (Derived)","text":"<p>These functions are built upon the basic trigonometric functions.</p> <ul> <li>cot(a): Calculates the cotangent of <code>a</code> (1 / tan(a)).</li> <li>sec(a): Calculates the secant of <code>a</code> (1 / cos(a)).</li> <li>csc(a): Calculates the cosecant of <code>a</code> (1 / sin(a)).</li> <li>hypot(a, b): Calculates the hypotenuse of a right triangle with sides <code>a</code> and <code>b</code> using the Pythagorean theorem.</li> </ul>"},{"location":"advanced-math/#hyperbolic-functions","title":"Hyperbolic Functions","text":"<p>These functions deal with hyperbolic trigonometric concepts.</p> <ul> <li>sinh(a): Calculates the hyperbolic sine of <code>a</code>.</li> <li>cosh(a): Calculates the hyperbolic cosine of <code>a</code>.</li> <li>tanh(a): Calculates the hyperbolic tangent of <code>a</code>.</li> <li>asinh(a): Calculates the inverse hyperbolic sine of <code>a</code>.</li> <li>acosh(a): Calculates the inverse hyperbolic cosine of <code>a</code>.</li> <li>atanh(a): Calculates the inverse hyperbolic tangent of <code>a</code>.</li> </ul>"},{"location":"advanced-math/#vector-math-functions-requires-vector3-objects","title":"Vector Math Functions (Requires Vector3 objects)","text":"<p>These functions operate on Roblox's <code>Vector3</code> objects.</p> <ul> <li>dot(a, b): Calculates the dot product of vectors <code>a</code> and <code>b</code>.</li> <li>cross(a, b): Calculates the cross product of vectors <code>a</code> and <code>b</code>, resulting in a new vector.</li> <li>magnitude(a): Calculates the magnitude (length) of vector <code>a</code>.</li> <li>normalize(a): Returns a new vector in the same direction as <code>a</code></li> <li>distance(a, b): Calculates the distance between two points represented by vectors <code>a</code> and <code>b</code>.</li> <li>angleBetween(a, b): Calculates the angle in radians between two vectors <code>a</code> and <code>b</code>.</li> </ul>"},{"location":"advanced-math/#matrix-math-functions","title":"Matrix Math Functions","text":"<p>These functions operate on 4x4 matrices (represented as tables). Note: The <code>invertMatrix</code> function is currently not implemented and returns the identity matrix.</p> <ul> <li>multiplyMatrix(a, b): Multiplies two 4x4 matrices <code>a</code> and <code>b</code> and returns the resulting product matrix.</li> <li>invertMatrix(a): This function is currently not implemented and returns the identity matrix instead. (Placeholder for future implementation)</li> </ul>"},{"location":"advanced-math/#statistical-functions","title":"Statistical Functions","text":"<p>These functions perform calculations on tables containing numerical data.</p> <ul> <li>mean(numbers): Calculates the average of the values in the <code>numbers</code> table.</li> <li>median(numbers): Calculates the median of the values in the <code>numbers</code> table (middle value when sorted).</li> <li>mode(numbers): Calculates the most frequent value (mode) in the <code>numbers</code> table.</li> <li>standardDeviation(numbers): Calculates the standard deviation of the values in the <code>numbers</code> table.</li> </ul> <p>This concludes the documentation for the <code>math_module</code> functions.</p> <p>Note: This documentation may be out of date or may contain errors.</p>"},{"location":"timer/","title":"Timer Module","text":""},{"location":"timer/#roblox-timer-module-documentation","title":"Roblox Timer Module Documentation","text":"<p>This module provides a simple and versatile timer functionality for your Roblox scripts. It allows creating timers with minutes and seconds, pausing/resuming them, and receiving notifications when the timer finishes.</p> <p>Features:</p> <ul> <li>Create timers with minutes and seconds.</li> <li>Optional progress callback to track remaining time during countdown.</li> <li>Pause and resume timers.</li> <li>Reset timers back to their original duration.</li> <li>Fire a custom event (optional) when the timer finishes.</li> </ul> <p>How to Use:</p> <ol> <li>Place the following script inside a <code>ModuleScript</code> in <code>ReplicatedStorage</code>.</li> </ol> <p><code>Timer.lua</code>:</p> <pre><code>local module = {}\n\nlocal function getFormattedTime(seconds)\n  local minutes = math.floor(seconds / 60)\n  local secondsLeft = seconds - minutes * 60\n  return minutes .. \"m \" .. secondsLeft .. \"s\"\nend\n\nlocal function timerThread(timer)\n  while timer.running do\n    wait(1)\n    if not timer.paused then\n      timer.remainingTime = timer.remainingTime - 1\n      if timer.remainingTime &lt;= 0 then\n        timer.running = false\n        timer.finishedEvent:Fire()\n      elseif timer.progressCallback then\n        timer.progressCallback(timer.remainingTime)\n      end\n    end\n  end\nend\n\nfunction module.new(minutes, seconds, finishedCallback, progressCallback, eventName)\n  local totalSeconds = minutes * 60 + seconds\n  local timer = {\n    remainingTime = totalSeconds,\n    running = true,\n    paused = false,\n    finishedEvent = eventName and Instance.new(\"BindableEvent\", eventName) or Instance.new(\"BindableEvent\"),\n    progressCallback = progressCallback,\n  }\n  if finishedCallback then\n    timer.finishedEvent:Connect(finishedCallback)\n  end\n  task.delay(0, function()\n    timerThread(timer)\n  end)\n  return timer\nend\n\nfunction module.getTimeLeft(timer)\n  if not timer.running then\n    return \"Timer Finished\"\n  end\n  return getFormattedTime(timer.remainingTime)\nend\n\nfunction module.pauseTimer(timer)\n  if timer.running then\n    timer.paused = true\n  end\nend\n\nfunction module.resumeTimer(timer)\n  if timer.paused then\n    timer.paused = false\n  end\nend\n\nfunction module.resetTimer(timer)\n  timer.remainingTime = timer.originalTime or 0 -- Consider adding an optional originalTime argument to new\n  timer.paused = false\nend\n\nreturn module\n</code></pre> <ol> <li>In any script, require the module:</li> </ol> <pre><code>local Timer = require(game.ReplicatedStorage.Timer)\n</code></pre> <p>Example Script:</p> <pre><code>local function onTimerFinish()\n  print(\"Timer finished!\")\nend\n\nlocal function onProgress(timeLeft)\n  print(\"Time remaining: \" .. Timer.getTimeLeft(myTimer))\nend\n\nlocal myTimer = Timer.new(\n  1, -- Minutes\n  30, -- Seconds\n  onTimerFinish, -- Finished Callback (Optional)\n  onProgress,  -- Progress Callback (Optional)\n  \"MyCustomFinishedEvent\" -- Custom Event Name (Optional)\n)\n\n-- After 1 minute and 30 seconds:\n--  * onTimerFinish function will be called.\n--  * onProgress function will be called periodically with remaining time.\n--  * \"MyCustomFinishedEvent\" will fire (if provided).\n\n-- You can pause, resume, and reset the timer:\nTimer.pauseTimer(myTimer)\nwait(30) -- Wait for 30 seconds\nTimer.resumeTimer(myTimer)\n\n-- Reset the timer back to 1 minute 30 seconds\nTimer.resetTimer(myTimer)\n</code></pre> <p>Additional Notes:</p> <ul> <li>The <code>finishedCallback</code> and <code>progressCallback</code> are optional arguments in the <code>new</code> function.</li> <li>If no custom event name is provided, a default <code>BindableEvent</code> is created.</li> <li>Use <code>Timer.getTimeLeft(timer)</code> to get the remaining time in a formatted string or \"Timer Finished\" if the timer has stopped.</li> </ul> <p>This documentation provides a basic overview of the module. You can explore the source code (<code>Timer.lua</code>) for a detailed understanding of each function and its behavior.</p>"}]}